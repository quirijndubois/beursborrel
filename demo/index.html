<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Stock Live Chart Dashboard</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        /* Define custom font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark gray background (bg-gray-900) */
            color: #f9fafb; /* Default light text (text-gray-50) */
            /* Increased padding-top to give space below the new, taller fixed ticker */
            padding-top: 4rem; 
        }
        
        /* Custom styling for the chart container */
        .chart-container {
            /* REMOVED max-width: 900px; to allow full width */
            width: 100%; 
            margin: 0 auto;
            background-color: #1f2937; /* Slightly lighter dark card (bg-gray-800) */
            box-shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.4), 0 4px 10px -2px rgba(0, 0, 0, 0.2);
            border-radius: 1rem; /* Rounded corners */
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            border: 1px solid #374151; /* Subtle border for definition */
            
            /* CALCULATED HEIGHT TO FILL SCREEN MINUS TICKET AND BODY PADDING/MARGINS */
            min-height: calc(100vh - 8rem); 
        }

        /* Ticker styling for smooth horizontal flow */
        .ticker-container {
            overflow: hidden;
            width: 100%;
            height: 60px; /* Increased height from 40px to 60px */
            background-color: #0d0d0d; /* Even darker for the ticker bar */
        }
        #stockTicker {
            display: inline-flex;
            width: max-content;
            animation: scroll-left linear infinite;
        }
        /* Define the scrolling animation */
        @keyframes scroll-left {
            0% { transform: translateX(0); }
            /* Adjusted to 25% because we duplicate the content 4x in JS for robustness */
            100% { transform: translateX(-25%); } 
        }
        /* Add transition for the fade effect on stock switch */
        #chartWrapper {
            transition: opacity 0.3s ease-in-out; 
        }
    </style>
</head>
<!-- Adjusted body padding for full screen effect, now set to 4rem (64px) for the taller ticker -->
<body class="p-4 min-h-screen" style="padding-top: 4rem;">

    <!-- Horizontal Scrolling Ticker -->
    <div class="fixed top-0 left-0 right-0 z-10 ticker-container">
        <!-- The actual container that will be animated/filled -->
        <!-- Added pt-2 pb-2 to center the content vertically in the new 60px height -->
        <div id="stockTicker" class="py-2 text-base text-gray-200">
            <!-- Ticker items will be dynamically inserted here by JS -->
        </div>
    </div>

    <!-- Chart container is now full-screen height (minus ticker/padding) -->
    <div class="chart-container">
        <!-- Header Section -->
        <div class="flex justify-between items-center mb-6 border-b border-gray-700 pb-4">
            <div>
                <!-- Display the currently focused stock symbol and name -->
                <h1 id="currentStockName" class="text-2xl sm:text-3xl font-bold text-gray-100">Loading...</h1>
            </div>
            <div class="text-right">
                <!-- Current Price (Dynamically updated by JS) -->
                <p id="currentPrice" class="text-3xl sm:text-4xl font-extrabold text-white leading-none">--.--</p>
                <!-- Change and Percentage (Dynamically updated by JS, color determines gain/loss) -->
                <p id="changeText" class="text-lg font-semibold mt-1 text-gray-400">Loading...</p>
            </div>
        </div>

        <!-- Canvas for the Chart (Now inside a wrapper for fade effect) -->
        <!-- flex-grow ensures this wrapper takes all available space -->
        <div id="chartWrapper" class="relative flex-grow">
            <canvas id="stockChart"></canvas>
        </div>
    </div>

    <script>
        // --- Global State and Configuration ---
        let stockChartInstance = null;
        let currentStockIndex = 0; // Index of the stock currently displayed on the main chart
        const maxDataPoints = 50; 
        const tickIntervalMs = 2000; // Data update every 2 seconds
        const autoSwitchIntervalMs = 5000; // Switch main chart every 5 seconds
        
        // Updated stock names, symbols, and initial base prices/volatility
        let stocks = [
            // Beer (starts at 3.00)
            { id: 0, name: 'Beer', symbol: 'BER', prices: [], labels: [], initialBasePrice: 3.00, volatility: 0.15, nextLabelIndex: 1 },
            // Vodka (starts at 5.00)
            { id: 1, name: 'Vodka', symbol: 'VOD', prices: [], labels: [], initialBasePrice: 5.00, volatility: 0.20, nextLabelIndex: 1 },
            // Wine (starts at 4.00)
            { id: 2, name: 'Wine', symbol: 'WIN', prices: [], labels: [], initialBasePrice: 4.00, volatility: 0.10, nextLabelIndex: 1 },
            // Rocket Shot (starts at 3.50)
            { id: 3, name: 'Rocket Shot', symbol: 'RKT', prices: [], labels: [], initialBasePrice: 3.50, volatility: 0.25, nextLabelIndex: 1 },
            // Soda (starts at 3.00)
            { id: 4, name: 'Soda', symbol: 'SDA', prices: [], labels: [], initialBasePrice: 3.00, volatility: 0.05, nextLabelIndex: 1 },
        ];
        
        // --- Helper Functions ---
        
        // Exponential Backoff implementation (kept for API best practice)
        async function fetchWithRetry(fn, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    if (i === retries - 1) {
                        throw error;
                    }
                    await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                }
            }
        }

        /**
         * Calculates the next price based on the last price for a given stock.
         * @param {Object} stock The stock object containing prices and initialBasePrice.
         * @returns {number} The new price.
         */
        function generateNextPrice(stock) {
            // Check if prices array is populated, otherwise use initialBasePrice
            const lastPrice = stock.prices.length > 0 ? stock.prices[stock.prices.length - 1] : stock.initialBasePrice;
            const change = (Math.random() - 0.5) * stock.volatility; 
            let newPrice = lastPrice + change;

            // Prevent price from straying too far from the base price for simulation
            const stabilityRange = 1.00; // Keep price within $1.00 of the base price
            const pullBackFactor = 0.1; // How much to pull the price back if it hits a bound
            
            if (newPrice < stock.initialBasePrice - stabilityRange) {
                newPrice = stock.initialBasePrice - stabilityRange + Math.random() * pullBackFactor;
            } else if (newPrice > stock.initialBasePrice + stabilityRange) {
                 newPrice = stock.initialBasePrice + stabilityRange - Math.random() * pullBackFactor;
            }
            
            // Ensure the price doesn't go below 0 
            if (newPrice < 0.01) {
                newPrice = 0.01;
            }

            return parseFloat(newPrice.toFixed(2));
        }

        /**
         * Updates the header section with the current price, change, and percentage for the focused stock.
         */
        function updateHeader(stock) {
            const startingPrice = stock.prices[0];
            const lastPrice = stock.prices[stock.prices.length - 1];
            
            if (startingPrice === undefined || lastPrice === undefined) return;

            const change = lastPrice - startingPrice;
            const percentageChange = (change / startingPrice) * 100;
            const isPositive = change >= 0;

            const changeTextElement = document.getElementById('changeText');
            document.getElementById('currentStockName').textContent = `${stock.symbol} | ${stock.name}`;
            document.getElementById('currentPrice').textContent = new Intl.NumberFormat('en-US', { 
                maximumFractionDigits: 2, 
                minimumFractionDigits: 2 
            }).format(lastPrice);
            
            changeTextElement.textContent = `${isPositive ? '▲' : '▼'} ${Math.abs(change).toFixed(2)} (${Math.abs(percentageChange).toFixed(2)}%)`;
            
            // Apply green/red coloring for dark mode contrast
            changeTextElement.className = `text-lg font-semibold mt-1 ${isPositive ? 'text-green-400' : 'text-red-400'}`;
        }
        
        /**
         * Renders the continuously scrolling ticker at the top.
         */
        function updateTicker() {
            const tickerContainer = document.getElementById('stockTicker');
            
            // To ensure seamless scrolling, we duplicate the entire content of the ticker
            const tickerContent = stocks.map(stock => {
                const startPrice = stock.prices[0];
                const lastPrice = stock.prices[stock.prices.length - 1];
                
                if (startPrice === undefined || lastPrice === undefined) return '';

                const change = lastPrice - startPrice;
                const percentageChange = (change / startPrice) * 100;
                const isPositive = change >= 0;
                const colorClass = isPositive ? 'text-green-400' : 'text-red-400';
                const arrow = isPositive ? '▲' : '▼';
                
                return `
                    <span class="inline-block px-8 py-0.5 border-r border-gray-800 tracking-wider">
                        <span class="font-bold text-gray-300">${stock.symbol}</span> 
                        <!-- FIX: Added min-w-[4rem] to price and min-w-[5rem] to percentage to prevent width jitter -->
                        <span class="mx-2 font-mono inline-block text-right min-w-[4rem]">${new Intl.NumberFormat('en-US', { minimumFractionDigits: 2 }).format(lastPrice)}</span>
                        <span class="${colorClass} font-semibold inline-block text-right min-w-[5rem]">${arrow} ${Math.abs(percentageChange).toFixed(2)}%</span>
                    </span>
                `;
            }).join('');

            // CRITICAL FIX: Duplicate content multiple times to ensure the loop is seamless and robust
            tickerContainer.innerHTML = tickerContent + tickerContent + tickerContent + tickerContent;

            // Only need to set animation duration once based on content length
            const duration = stocks.length * 4; // 4 seconds per stock item on screen
            tickerContainer.style.animationDuration = `${duration}s`;
        }


        /**
         * Renders the main chart using the data from the currently selected stock.
         * This function handles both initial creation and content switching (via fade transition).
         */
        function renderMainChart() {
            const stock = stocks[currentStockIndex];
            
            // Update Header first
            updateHeader(stock);

            const isPositive = stock.prices[stock.prices.length - 1] >= stock.prices[0];
            const mainColor = isPositive ? '#34d399' : '#f87171'; // Green-400 or Red-400
            const lightColor = isPositive ? 'rgba(52, 211, 153, 0.05)' : 'rgba(248, 113, 113, 0.05)';

            const ctx = document.getElementById('stockChart').getContext('2d');
            
            // Define Gradient dynamically based on performance
            const gradient = ctx.createLinearGradient(0, 0, 0, 400); 
            gradient.addColorStop(0, mainColor + '60'); 
            gradient.addColorStop(1, lightColor);
            
            // If the chart instance exists, update it, otherwise create it
            if (stockChartInstance) {
                stockChartInstance.data.labels = stock.labels;
                stockChartInstance.data.datasets[0].data = stock.prices;
                stockChartInstance.data.datasets[0].borderColor = mainColor;
                
                // CRITICAL FIX: Update background color (gradient)
                stockChartInstance.data.datasets[0].backgroundColor = gradient;
                stockChartInstance.data.datasets[0].pointHoverBackgroundColor = mainColor;
                
                // Using 'none' to avoid Chart.js animation conflicting with CSS fade
                stockChartInstance.update('none'); 
            } else {
                stockChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: stock.labels,
                        datasets: [{
                            label: 'Price',
                            data: stock.prices,
                            borderColor: mainColor, 
                            backgroundColor: gradient, 
                            fill: 'start', 
                            tension: 0, // Unsmoothed (jagged) lines
                            pointRadius: 0, 
                            borderWidth: 3,
                            pointHoverRadius: 5, 
                            pointHoverBackgroundColor: mainColor,
                            pointHoverBorderColor: '#1f2937', 
                            pointHoverBorderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                backgroundColor: 'rgba(55, 65, 81, 0.9)',
                                titleFont: { size: 14, weight: 'bold', color: 'white' },
                                bodyFont: { size: 14, color: 'white' },
                                cornerRadius: 6,
                                padding: 10,
                                displayColors: false, 
                                callbacks: {
                                    title: function(context) { return context[0].label; },
                                    label: function(context) {
                                        const value = context.parsed.y;
                                        return 'Price: ' + new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 2 }).format(value);
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: false,
                                grid: { color: 'rgba(255, 255, 255, 0.15)', drawBorder: false },
                                ticks: {
                                    color: '#d1d5db',
                                    padding: 10,
                                    callback: function(value) {
                                        return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', notation: 'compact', compactDisplay: 'short' }).format(value);
                                    }
                                }
                            },
                            x: {
                                grid: { 
                                    display: true, // Display vertical grid lines
                                    color: 'rgba(255, 255, 255, 0.05)' // Subtle color for vertical lines
                                },
                                ticks: {
                                    color: '#d1d5db',
                                    maxTicksLimit: 10,
                                    callback: function(value, index, ticks) {
                                        return (index % 10 === 0 || index === ticks.length - 1) ? this.getLabelForValue(value) : '';
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }

        /**
         * Adds a new price point to ALL stocks and updates the ticker.
         */
        function tickData() {
            stocks.forEach(stock => {
                // 1. Calculate new price
                const newPrice = generateNextPrice(stock);

                // 2. Shift data (FIFO - First In, First Out)
                if (stock.prices.length >= maxDataPoints) {
                    stock.prices.shift();
                    stock.labels.shift();
                }

                // 3. Push new data
                stock.prices.push(newPrice);
                stock.labels.push(`P ${stock.nextLabelIndex++}`);
            });

            // Update the ticker bar with the latest performance data
            updateTicker();
            
            // If the current stock is being displayed, update its chart instance silently
            if (stockChartInstance) {
                 // Use the current stock data to update the chart in place
                 const currentStock = stocks[currentStockIndex];
                 stockChartInstance.data.labels = currentStock.labels;
                 stockChartInstance.data.datasets[0].data = currentStock.prices;
                 
                 // Recalculate colors and update header
                 updateHeader(currentStock);

                 const isPositive = currentStock.prices[currentStock.prices.length - 1] >= currentStock.prices[0];
                 const mainColor = isPositive ? '#34d399' : '#f87171'; // Green-400 or Red-400
                 const lightColor = isPositive ? 'rgba(52, 211, 153, 0.05)' : 'rgba(248, 113, 113, 0.05)';

                 // REDEFINE AND REAPPLY GRADIENT CONTEXT
                 const ctx = stockChartInstance.canvas.getContext('2d');
                 const gradient = ctx.createLinearGradient(0, 0, 0, 400); 
                 gradient.addColorStop(0, mainColor + '60'); 
                 gradient.addColorStop(1, lightColor);

                 stockChartInstance.data.datasets[0].borderColor = mainColor;
                 stockChartInstance.data.datasets[0].pointHoverBackgroundColor = mainColor;
                 // CRITICAL FIX: Update background color (gradient)
                 stockChartInstance.data.datasets[0].backgroundColor = gradient;
                 
                 stockChartInstance.update('none'); // Use 'none' for instant update without animation
            }
        }
        
        /**
         * Switches the main chart to the next stock in the array with a fade transition.
         */
        function switchStock() {
            const wrapper = document.getElementById('chartWrapper');
            
            // 1. Start fade out
            wrapper.style.opacity = '0'; 
            wrapper.style.pointerEvents = 'none'; // Prevent interaction during transition

            // Wait for fade-out duration (300ms) before switching content
            setTimeout(() => {
                currentStockIndex = (currentStockIndex + 1) % stocks.length;
                renderMainChart(); // This updates the chart data

                // 2. Start fade in
                wrapper.style.opacity = '1';
                wrapper.style.pointerEvents = 'auto';
            }, 300); 
        }

        /**
         * Initializes the dashboard with initial data and starts the update loops.
         */
        function initializeDashboard() {
            // 1. Populate initial data for all stocks
            stocks.forEach(stock => {
                let currentPrice = stock.initialBasePrice;
                for (let i = 0; i < maxDataPoints; i++) {
                    // Pass the entire 'stock' object to generateNextPrice.
                    currentPrice = generateNextPrice(stock); 
                    stock.prices.push(currentPrice);
                    stock.labels.push(`P ${stock.nextLabelIndex++}`);
                }
            });

            // 2. Render the initial main chart (first stock)
            renderMainChart();
            
            // 3. Render the initial ticker
            updateTicker();

            // 4. Start the continuous data update loop (for all stocks and ticker)
            setInterval(tickData, tickIntervalMs);

            // 5. Start the main chart auto-switching loop
            setInterval(switchStock, autoSwitchIntervalMs);
        }

        window.onload = initializeDashboard;
    </script>

</body>
</html>
